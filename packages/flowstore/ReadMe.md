#mz数据流

###背景
mz数据流实现子节点能访问父节点数据，并且父级数据变化后能同步更新。
主要通过vue props实现，vue自带自动更新同步，父级props改变会影响所有子级（容易多更新）
mz所有的数据都是动态的，加剧了以上情况（跟vue更新机制有关，宁愿多更新，不能漏更新 ）

###基本原则
mz的特点，只能优化运行时（运行时才能拿到最终数据，设计时或者配置时无法提前优化）
不多更新：运行时按需访问，精准更新，保证性能
先查找（此期间不能导致被getter，防止多更新），再访问 （此期间需要被getter ，避免漏更新）
不漏更新：主要针对动态情况，宁愿多更新，也不能漏更新，保证逻辑正常。（这也是vue的策略）

之前通过props 实现，在组件内通过props传输，每次flow上某个节点的值改变，会导致下级节点的flow“重建”（越是父节点的变动，影响范围越大，这样容易多更新，但是能保证逻辑正常），本次期望不通过props，放到组件外头，类似于一个flowstore，尽量复用已有flow（容易造成漏更新）。

###冲突
mz数据流与vue自身机制(vue会对数据劫持，自动实现依赖收集和自动更新 )的冲突，如：
 1，获取就会被依赖，但是通过其它途径，譬如Object.getOwnPropertyDescriptor(o, source).value会失效 (value属性被重写）
 2，按理说对象原型技术是最合适使用的技术，可以做到精准访问，自动内部查找，原生支持。如果proto链上存在同名的属性，且原型对象是一个被vue劫持过的对象，则对象设置属性会被优先拦截(get,set) 。 不使用proto的另一个原因是无法做到不访问实现下面的功能（这在vue里很重要，也是当下要改造数据流的主要原因）。（原来是这样实现的，目前这块已经改造成proxy）
3，如果是一个proxy对象，也会被劫持重新defineProperty导致有问题 ，需要添加特殊标记避免，但是这样失去了自动响应式的特性，需要自己去保证。


###典型场景
1，查找过程中如何不访问，实现类似于proto的效果？
先判断属性有无，hasOwnProperty 

2，查找过程中，如何不访问能拿到下级对象的所有属性情况？
obj= {a:{b:{name,age}}}  , 不访问，如何知道obj中是否包含name属性？（obj可能是一个被vue劫持的对象，Object.getOwnPropertyDescriptor(o, source).value会失效）

3， 祖节点动态新增了一个属性（之前没有这个属性），子节点可能用到了这个属性也可能没用到
//     为了保证逻辑正常，此种情况需要必要的多更新
//     尽量避免父节点打开子节点还动态添加属性的情况

4，当前节点
实现store的数据管理功能，支持commit/dispatch
限制可访问范围，setlocal ，只能访问本节点的数据

5，插入功能
如在当前节点上级插入一级节点
flow:{a} - {b}   => flow1: {a} - {xxx} - {b}

6，数据分发
如一个对象，按照字段名称分发
flow:{a:{aaa}，b:{bbb}}  =>  flow:1 {aaa}
                                     =>   flow:2 {bbb}
如一个列表，按照索引分发
flow:[{1},{2}]  => flow1: {1}
               =>  flow2:{2}
7，数据变换
如新增一个字段a指向现有的A，值是一个
flow : {a:1,b:2}  =>flow1: {$value:a}
           =>flow2: {$value:b}

8，原生方法支持，如 in 支持，hasOwnproperty，Object.keys ，即通过proxy对外表现类似于一个基于原型proto的对象
Set flow = {a:1} - {b:2} -{c:3}  
        "a" in flow == true

9，整个flow数据是可响应的 （除非它本身不是一个可响应的属性）
Set flow = {a:1} - {b:2} - {c:3}   
       {{flow.a}}  show 1
Set a = 2 , auto show 2 

10，考虑动态字段情况（容易多更新和漏更新）
          Set flow = {a:1} - {b:2} - {c:3}   
{{flow.m}}  show null
Set m = 1 auto show 1

11， 以上插入/分发/变换等过程中不能造成“访问”，防止产生依赖 , 导致数据变换flow被”重建“
